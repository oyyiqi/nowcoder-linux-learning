# <center> 1.共享内存

## **1.1shmget()**

**1. 功能说明：**

`shmget` 函数用于创建或获取一个共享内存段（shared memory segment）。共享内存是一种高效的进程间通信方式，允许多个进程共享同一块物理内存区域，实现数据交换和通信。

**2. 函数原型：**

```c
#include <sys/ipc.h>
#include <sys/shm.h>

int shmget(key_t key, size_t size, int shmflg);
```

**3. 参数说明：**

- `key`：共享内存段的键值，用于标识共享内存段。不同进程通过相同的 `key` 可以访问同一个共享内存段。通常可以使用 `ftok` 函数生成一个唯一的键值。
- `size`：指定共享内存段的大小，以字节为单位。
- `shmflg`：用于指定创建共享内存段的方式和权限标志，可以是以下之一或它们的组合：
  - `IPC_CREAT`：如果共享内存段不存在，则创建一个新的。
  - `IPC_EXCL`：与 `IPC_CREAT` 一起使用，如果共享内存段已经存在，则创建失败。
  - `0666`：指定共享内存段的权限，表示所有用户都有读写权限。

**4. 返回值：**

- 成功时返回共享内存段的标识符（共享内存的ID），即共享内存段的标识。
- 失败时返回 -1，并设置全局变量 `errno` 表示具体的错误信息。

**5. 使用示例：**

```c
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>

int main() {
    int shmid;
    key_t key = ftok("/tmp", 'A');
    if (key == -1) {
        perror("ftok");
        return 1;
    }

    // 创建共享内存段，大小为 1024 字节
    shmid = shmget(key, 1024, IPC_CREAT | 0666);
    if (shmid == -1) {
        perror("shmget");
        return 1;
    }

    printf("共享内存段的标识符：%d\n", shmid);

    return 0;
}
```

在上述示例中，我们演示了如何使用 `shmget` 函数创建一个共享内存段，并获取共享内存段的标识符。首先，通过 `ftok` 函数生成一个唯一的键值 `key`，然后使用 `shmget` 函数创建一个大小为 1024 字节的共享内存段。在创建时，我们指定了 `IPC_CREAT` 标志表示如果共享内存段不存在，则创建一个新的，同时指定权限为 0666 表示所有用户都有读写权限。创建成功后，`shmget` 函数返回共享内存段的标识符 `shmid`，然后我们将其打印输出。

需要注意的是，在实际应用中，通常会有多个进程通过相同的键值 `key` 来访问同一个共享内存段，从而实现进程间的数据共享和通信。而示例中只是演示了共享内存的创建过程，实际使用时还需要考虑进程间同步和数据交换的问题。

---

## **1.2 shmat()**

**1. 功能说明：**

`shmat` 函数用于将共享内存段（shared memory segment）连接到调用进程的地址空间，从而使得进程可以访问共享内存中的数据。

**2. 函数原型：**

```c
#include <sys/types.h>
#include <sys/shm.h>

void *shmat(int shmid, const void *shmaddr, int shmflg);
```

**3. 参数说明：**

- `shmid`：共享内存段的标识符，即共享内存的ID，由 `shmget` 函数返回。
- `shmaddr`：指定共享内存连接的地址，通常设置为 `NULL`，由系统自动选择合适的地址。
- `shmflg`：用于指定共享内存的连接方式和权限标志，可以是以下之一或它们的组合：
  - `SHM_RDONLY`：只读方式连接共享内存，该进程只能读取共享内存中的数据，不能修改。必须有读权限
  - `0`：读写方式连接共享内存，该进程可以读取和修改共享内存中的数据。

**4. 返回值：**

- `shmat` 函数成功时返回共享内存连接后的地址指针，即进程访问共享内存的起始地址。
- 失败时返回 `(void *)-1`，表示共享内存连接失败。

**5. 使用示例：**

```c
#include <sys/types.h>
#include <sys/shm.h>
#include <stdio.h>

int main() {
    int shmid;
    key_t key = ftok("/tmp", 'A');
    if (key == -1) {
        perror("ftok");
        return 1;
    }

    // 获取共享内存段的标识符
    shmid = shmget(key, 1024, IPC_CREAT | 0666);
    if (shmid == -1) {
        perror("shmget");
        return 1;
    }

    // 将共享内存连接到当前进程的地址空间
    void *shm_ptr = shmat(shmid, NULL, 0);
    if (shm_ptr == (void *)-1) {
        perror("shmat");
        return 1;
    }

    // 通过shm_ptr指针访问共享内存中的数据
    // ...

    // 断开共享内存的连接
    int ret = shmdt(shm_ptr);
    if (ret == -1) {
        perror("shmdt");
        return 1;
    }

    return 0;
}
```

在上述示例中，我们演示了如何使用 `shmat` 函数将共享内存段连接到当前进程的地址空间，并通过返回的 `shm_ptr` 指针来访问共享内存中的数据。在连接共享内存后，我们可以通过指针 `shm_ptr` 来读取或修改共享内存中的数据。注意，连接共享内存后，我们在不需要访问共享内存时应该调用 `shmdt` 函数来断开连接。

需要注意的是，共享内存的使用涉及到进程间的同步问题，多个进程同时访问共享内存时应该注意避免竞态条件等问题。示例中只是演示了共享内存的连接过程，实际使用时需要根据具体需求来设计进程间的数据访问和同步机制。

---

## **1.3 shmdt()**

**1. 功能说明：**

`shmdt` 函数用于断开当前进程与共享内存段的连接，即解除共享内存的映射，使得进程不能再访问共享内存中的数据。

**2. 函数原型：**

```c
#include <sys/types.h>
#include <sys/shm.h>

int shmdt(const void *shmaddr);
```

**3. 参数说明：**

- `shmaddr`：共享内存连接的地址指针，即调用 `shmat` 函数时返回的地址指针。

**4. 返回值：**

- `shmdt` 函数成功时返回 0，表示成功解除共享内存的映射。
- 失败时返回 -1，表示解除共享内存映射失败。

**5. 使用示例：**

```c
#include <sys/types.h>
#include <sys/shm.h>
#include <stdio.h>

int main() {
    int shmid;
    key_t key = ftok("/tmp", 'A');
    if (key == -1) {
        perror("ftok");
        return 1;
    }

    // 获取共享内存段的标识符
    shmid = shmget(key, 1024, IPC_CREAT | 0666);
    if (shmid == -1) {
        perror("shmget");
        return 1;
    }

    // 将共享内存连接到当前进程的地址空间
    void *shm_ptr = shmat(shmid, NULL, 0);
    if (shm_ptr == (void *)-1) {
        perror("shmat");
        return 1;
    }

    // 通过shm_ptr指针访问共享内存中的数据
    // ...

    // 断开共享内存的连接
    int ret = shmdt(shm_ptr);
    if (ret == -1) {
        perror("shmdt");
        return 1;
    }

    return 0;
}
```

在上述示例中，我们演示了如何使用 `shmdt` 函数断开共享内存段与当前进程的连接。首先，我们通过 `shmat` 函数将共享内存段连接到当前进程的地址空间，然后通过 `shm_ptr` 指针访问共享内存中的数据。在不再需要访问共享内存时，我们通过调用 `shmdt` 函数来解除与共享内存的连接。

需要注意的是，断开共享内存的连接并不会删除共享内存段，只是解除了当前进程与共享内存的映射关系，其他进程仍然可以继续访问共享内存。如果不再需要使用共享内存，应该通过调用 `shmctl` 函数来删除共享内存段。示例中只是演示了共享内存的连接和断开连接过程，实际使用时还需要根据具体需求来管理共享内存的生命周期。

---

## **1.4 shmctl()**

**1. 功能说明：**

`shmctl` 函数用于对共享内存段进行控制操作，包括获取共享内存信息、设置共享内存权限、删除共享内存段等。

**2. 函数原型：**

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int shmctl(int shmid, int cmd, struct shmid_ds *buf);
```

**3. 参数说明：**

- `shmid`：共享内存段的标识符，即共享内存的ID，由 `shmget` 函数返回。
- `cmd`：控制命令，用于指定要执行的操作，可以是以下之一：
  - `IPC_STAT`：获取共享内存的信息，并将信息存储在 `buf` 指向的 `struct shmid_ds` 结构体中。
  - `IPC_SET`：设置共享内存的信息，需要将 `buf` 指向的 `struct shmid_ds` 结构体中的参数设置为新的值。
  - `IPC_RMID`：删除共享内存段，释放共享内存资源，此时`buf`无效
- `buf`：指向 `struct shmid_ds` 结构体的指针，用于存储共享内存的信息或设置共享内存的参数。
  - 

**4. 返回值：**

- `shmctl` 函数成功时返回操作的结果，具体返回值根据不同的 `cmd` 命令而定。通常情况下，返回值为 0 表示成功，-1 表示失败，并设置全局变量 `errno` 表示具体的错误信息。

**5. 使用示例：**

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>

int main() {
    int shmid;
    key_t key = ftok("/tmp", 'A');
    if (key == -1) {
        perror("ftok");
        return 1;
    }

    // 获取共享内存段的标识符
    shmid = shmget(key, 1024, IPC_CREAT | 0666);
    if (shmid == -1) {
        perror("shmget");
        return 1;
    }

    // 获取共享内存的信息
    struct shmid_ds shminfo;
    int ret = shmctl(shmid, IPC_STAT, &shminfo);
    if (ret == -1) {
        perror("shmctl");
        return 1;
    }

    printf("共享内存大小：%lu\n", shminfo.shm_segsz);

    // 删除共享内存段
    ret = shmctl(shmid, IPC_RMID, NULL);
    if (ret == -1) {
        perror("shmctl");
        return 1;
    }

    printf("共享内存已成功删除\n");

    return 0;
}
```

在上述示例中，我们演示了如何使用 `shmctl` 函数来获取共享内存段的信息和删除共享内存段。首先，我们通过 `shmget` 函数获取共享内存段的标识符 `shmid`，然后通过 `shmctl` 函数和命令 `IPC_STAT` 来获取共享内存段的信息，并将信息存储在 `shminfo` 结构体中。随后，我们打印共享内存的大小。接着，通过 `shmctl` 函数和命令 `IPC_RMID` 来删除共享内存段，释放共享内存资源。最后，我们打印删除成功的提示信息。

需要注意的是，删除共享内存段后，其他进程不能再访问该共享内存。示例中只是演示了 `shmctl` 函数的基本用法，实际使用时还需要根据具体需求来进行共享内存的控制操作。

---


## **1.5 ftok()**

**1. 功能说明：**

`ftok` 函数用于将一个路径名和一个整数值（项目标识符）转换为一个唯一的 `key_t` 类型的键值，该键值通常用于创建进程间通信（IPC）相关的资源，如消息队列、共享内存等。

**2. 函数原型：**

```c
#include <sys/types.h>
#include <sys/ipc.h>

key_t ftok(const char *pathname, int proj_id);
```

**3. 参数说明：**

- `pathname`：一个以 null 结尾的字符串，用于构造唯一的键值。通常指定一个文件的路径名作为 `pathname`，该文件必须存在且可读。如果文件不存在或不可读，将导致 `ftok` 函数调用失败。
- `proj_id`：项目标识符，是一个整数值，用于增加唯一性。通常为正整数，但不能为 0。

**4. 返回值：**

- `ftok` 函数成功时返回一个非负整数的 `key_t` 类型的键值，用于创建进程间通信的资源。
- 失败时返回 -1，并设置全局变量 `errno` 表示具体的错误信息。

**5. 使用示例：**

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <stdio.h>

int main() {
    const char *pathname = "/tmp/myfile";
    int proj_id = 42;

    key_t key = ftok(pathname, proj_id);
    if (key == -1) {
        perror("ftok");
        return 1;
    }

    printf("生成的key值为：%d\n", key);

    return 0;
}
```

在上述示例中，我们演示了如何使用 `ftok` 函数将文件路径名和项目标识符转换为一个唯一的键值 `key`，用于创建进程间通信相关的资源。首先，我们指定一个文件的路径名 `pathname` 和一个项目标识符 `proj_id`，然后调用 `ftok` 函数，将这两个参数传递给 `ftok` 函数。`ftok` 函数会根据给定的文件路径名和项目标识符生成一个唯一的键值 `key`，我们可以将该键值用于创建消息队列、共享内存等进程间通信资源。

需要注意的是，`ftok` 函数生成的键值在不同的系统上可能不同，因此在跨平台的程序中应该谨慎使用。另外，要确保指定的文件路径名存在且可读，否则将导致 `ftok` 函数调用失败。示例中只是演示了 `ftok` 函数的基本用法，实际使用时还需要根据具体需求来确定文件路径名和项目标识符，以确保生成的键值唯一且适合用于创建进程间通信资源。

---
## **1.6 共享内存总结**
Q1:操作系统如何知道一块共享内存被多少个进程关联
  - 操作系统维护了一个结构体`struct shmid_ds`,这个结构体中有一个成员`shm_nattach`记录了关联的进程个数
  - 可以通过`ipcs -m`命令查看共享内存的使用



Q2:可不可以使用`shmctl`共享内存执行多次删除？</r>
- 可以，一个共享内存可以关联到多个进程，当一个进程通过`shmctl`执行一次删除时，如果这块共享内存的连接数`shm_nattach > 0`，则只会将这块共享内存标记为删除，但并没有真正的删除，知道`shm_nattch = 0` 时，这块共享内存才会真正删除。

Q3: 共享内存和内存映射的区别
- 效率:内存映射是将磁盘文件映射到内存中，其读写会涉及文件IO，而共享内存是直接在内存中划出一块空间与用户虚拟地址空间进行映射，对共享内存的读写效率更高
- 生命周期:
  - 内存映射:进程退出，内存映射区销毁
  - 共享内存:进程退出会自动与共享内存取消关联，当共享内存的引用计数为0时销毁


Q4: 内存映射的原理是什么？为什么比一般的文件读写快？


- 内存映射就是为进程分配一段与磁盘文件大小相同的虚拟地址空间与磁盘文件位置进行一一对应，但实际上这个过程并没有发生实际的数据拷贝，只是建立了相关的数据结构`struct address_space`，记录了这个映射。下面解析为什么比一般文件的读写快.</r>

- 内存映射通过`mmap()`系统调用实现，返回分配的虚拟空间的首地址`addr`；完成内存映射后就可以通过`addr`进行文件读写。当进程第一次通过addr读取文件内容时，MMU(内存管理单元)将逻辑地址`addr`转换成物理地址的过程中发现，进程页表中没有该虚拟页面对应的物理页面，从而引发缺页中断，并由中断处理函数完成数据从文件到物理内存的拷贝。这个过程只发生了一次数据拷贝。


- 一般用户进程无法直接访问IO设备，只能通过系统调用使程序陷入内核态，由内核进程去访问IO设备。`read()`首先将文件内容从硬盘拷贝的内核空间的文件缓冲区，然后再将数据从内核缓存区，拷贝到用户空间。这个过程发生了两次数据拷贝，所以共享内存的读写效率更高。

- 同样写文件时内存映射和`write`也是类似的过程：通过内存映射写文件时，如果要写入数据的区域还没有被访问，一样会先引发**缺页中断**，通过**中断处理函数**先把文件内容拷贝到物理内存中，用户进程再把数据写入到这块物理内存，并标记这块内存为脏数据，最后又操作系统自动将脏数据写回文件中。`write()`会先将数据从用户空间的缓冲区拷贝到内核空间的缓冲区，然后在**某个时机**把内核缓冲区中的数据写回磁盘文件。

- 由于`read()和wirte()`会多次发生数据拷贝，内核通过读写缓冲等机制来提高读写效率，**具体可见~~【待补充】**

Q5:内核文件缓冲区的缓冲机制
内核文件缓冲区是内核中用于缓存文件数据的部分，它采用了缓冲机制来优化文件的读写性能。内核文件缓冲区的缓冲机制主要包括以下几个方面：

1. **读取缓冲（Read Buffering）：** 当用户进程执行文件读取操作时，内核会将读取的数据缓存在内核文件缓冲区中，而不是立即将数据传输到用户空间。这样，如果用户进程后续还需要读取相同的数据，内核可以直接从内核文件缓冲区中返回，避免重复的磁盘访问，提高了读取的效率。

2. **写入缓冲（Write Buffering）：** 当用户进程执行文件写入操作时，内核会将写入的数据先缓存在内核文件缓冲区中，而不是立即写入到磁盘。这样可以减少频繁的磁盘写入操作，将多个写入请求合并成一个较大的写入请求，减少了磁盘访问次数，提高了写入的效率。

3. **脏数据（Dirty Data）：** 当用户进程对内核文件缓冲区进行写入后，缓冲区的数据变为"脏数据"，即与磁盘上的数据不一致。为了确保数据的一致性，内核会在适当的时机将脏数据写回到磁盘，这个过程称为"脏数据回写"。脏数据回写可以由内核自动进行，也可以通过调用`sync()`系统调用来手动触发。

4. **缓冲区管理：** 内核文件缓冲区采用了缓冲区管理机制，用于维护缓冲区的状态和管理缓冲区的使用。内核会根据缓冲区的使用情况来动态调整缓冲区的大小，以适应不同的文件读写工作负载。

    总的来说，内核文件缓冲区的缓冲机制通过读取缓冲和写入缓冲来优化文件的读写性能，将数据暂时缓存在内存中，避免频繁的磁盘访问。同时，通过脏数据回写，保证了数据的一致性，使得缓冲区中的数据与磁盘上的数据保持同步。缓冲区管理机制则用于动态调整缓冲区的大小，以适应不同的工作负载，提高了整体的文件 I/O 性能。

Q6:脏数据一定会在读之前写回吗?

不，脏数据并不一定会在读取操作之前立即写回到磁盘。脏数据是指内核文件缓冲区中的数据与磁盘上的数据不一致，即缓冲区中的数据被修改过但还未写回到磁盘。

脏数据的回写是由操作系统内核来管理的，它会根据一定的策略和条件来决定何时将脏数据写回到磁盘。一般来说，操作系统会采取一些优化策略来减少频繁的磁盘写入，从而提高性能。以下是一些触发脏数据回写的常见情况：

1. **缓冲区满：** 当内核文件缓冲区占用的内存达到一定阈值时，操作系统可能会触发脏数据回写，以释放缓冲区并保持内存的合理使用。

2. **内存压力：** 当系统内存紧张时，为了腾出内存空间，操作系统可能会通过回写脏数据来释放内存，以满足其他进程的需求。

3. **定期回写：** 操作系统可能会定期触发脏数据的回写，以保证数据的一致性，并避免长时间的数据滞留在内存中。

4. **文件关闭：** 当一个文件被关闭时，操作系统会将该文件的脏数据写回到磁盘，以确保数据的持久化。

需要注意的是，脏数据回写的具体策略可能因操作系统的不同而有所差异，而且有时候可能会根据系统负载和内存使用情况等动态调整。由于脏数据回写可能会在读取操作之后执行，所以在应用程序中，如果需要确保数据写入到磁盘并且数据的一致性很重要，可以显式地调用`fsync()`或`fdatasync()`系统调用来强制将脏数据刷新回磁盘。

Q7:如何创建一个守护进程？

在 Linux 系统中，创建一个守护进程的一般步骤如下：

1. `fork()`出一个子进程，并使父进程退出：首先，一个普通的进程（通常是在后台运行的应用程序）会创建一个子进程，并使父进程退出，这样子进程就不再与终端关联，成为一个孤儿进程，而不会在终端关闭时接收到 `SIGHUP` 信号。

2. 设置子进程的进程组和会话ID：子进程通过调用 `setsid()` 函数创建一个新的会话，并成为该会话的首进程。这样子进程就会与原来的终端完全脱离关联，成为一个独立的会话和进程组的首进程。

3. 改变当前工作目录：为了避免进程在挂载的文件系统中导致文件系统被卸载，通常会将守护进程的当前工作目录改变为根目录（`chdir("/")`）。

4. 重设文件权限掩码：守护进程应该清除文件权限掩码，以确保它可以创建和打开文件时具有所需的权限（通常使用 `umask(0)`）。

5. 关闭文件描述符：守护进程应该关闭所有的文件描述符，因为它不再需要与终端或其他标准流（stdin、stdout、stderr）关联。

6. 执行守护进程的主要工作：此时，守护进程已经创建完成，并脱离了与终端的关联。它可以开始执行自己的任务或服务，并且在后台运行。

Q8:在创建守护进程的过程中为什么要先`fork()`再`setsid()`?

`setsid()`的调用者不能是一个进程组的组长的，如果不先执行`fork()`直接`setsid()`的话会失败[operation not permitted]，并返回-1，因此通常通过`fork()`创建一个子进程让子进程成为守护进程。【而`fork()`之后要让父进程退出，是为了让子进程完全脱离控制终端，因为如果`fork()`之后父进程不退出，即使子进程执行了`setsid()`成为了新会话的首进程，但由于他的父进程还被终端控制，子进程仍然会受到终端的控制：当终端关闭时会给与之关联的会话中的所有进程及其子进程发送`SIGHUP`信号，即使子进程与父进程不在一个会话中。做了测试好像并不是这样...，所以暂时不清楚为什么要退出父进程，可能的一个原因就是将终端释放出来，回到可以执行命令的状态。 代码位置:deamon_test.cpp】

---

# **2. 管道**

# **3. 信号**

## 3.1 sigaction()

**1. 功能说明：**

`sigaction` 是一个用于设置信号处理函数的系统调用函数，用于捕捉和处理信号。信号是在操作系统中用于通知进程发生某些事件的机制，例如用户按下终止进程的键盘组合键（如Ctrl+C），或者发生了除以零的错误。通过捕捉信号，进程可以采取相应的措施来处理这些事件。

**2. 函数原型：**

```c
#include <signal.h>

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

**3. 参数说明：**

- `signum`：一个整数值，表示要捕捉的信号编号。
- `act`：一个指向 `struct sigaction` 结构的指针，表示新的信号处理动作。
- `oldact`：一个指向 `struct sigaction` 结构的指针，用于存储旧的信号处理动作。

**4. 返回值：**

- 如果调用成功，`sigaction` 函数返回 0。
- 如果调用失败，返回值为 -1，并设置全局变量 `errno` 表示具体的错误信息。

**5. 总结：**

`sigaction` 函数用于设置信号处理函数，可以用来捕捉和处理特定信号，例如Ctrl+C（`SIGINT`）。通过设置新的信号处理动作，我们可以指定在接收到指定信号时要执行的操作，例如执行自定义信号处理函数、忽略信号、恢复默认处理等。

注意：信号处理函数应该尽量简洁，并避免在信号处理函数中调用不可重入的函数。使用 `sigaction` 函数时，还可以通过 `sa_mask` 字段指定在信号处理函数执行期间要阻塞的其他信号，以避免信号处理函数的嵌套调用。
