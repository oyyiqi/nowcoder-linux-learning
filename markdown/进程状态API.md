
# 1. fork()

**1. 功能说明：**

`fork` 函数用于创建一个新的进程，新进程是调用进程（父进程）的副本，两个进程共享同样的代码段、数据段、打开的文件等资源，但是拥有各自独立的地址空间。`fork` 函数的调用会导致在当前进程的地址空间中创建一个新的进程，称为子进程。父进程和子进程之间的关系是父子关系，子进程的 PID（进程标识符）是父进程的返回值。

`fork()`函数用于创建一个子进程

**2. 函数原型：**

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

**3. 参数说明：**

- `fork` 函数不接受任何参数。

**4. 返回值：**

- `fork` 函数在父进程中返回子进程的 PID（非负整数），在子进程中返回 0。如果创建子进程失败，`fork` 函数返回 -1，并设置全局变量 `errno` 表示具体的错误信息。

- `fork`函数如果调用失败会返回`-1`，并设置全局错误号`errno`
- `fork`函数如果调用成功，会返回两次，在父进程中返回子进程的`pid`，在子进程中返回`0`

**5. 使用示例：**

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    pid_t pid;

    // 创建子进程
    pid = fork();

    if (pid == -1) {
        perror("fork");
        return 1;
    }

    if (pid == 0) {
        // 在子进程中
        printf("这是子进程，PID：%d\n", getpid());
    } else {
        // 在父进程中
        printf("这是父进程，子进程的PID：%d\n", pid);
    }

    return 0;
}
```

在上述示例中，我们演示了如何使用 `fork` 函数创建一个新的子进程。首先，我们调用 `fork` 函数，该函数在父进程中返回子进程的 PID（非负整数），在子进程中返回 0。然后，我们根据返回值判断当前是在父进程还是在子进程中，并分别打印对应的信息。

需要注意的是，父进程和子进程是两个完全独立的进程，它们各自有各自的执行流程，并且互不干扰。在父进程中对变量的修改不会影响到子进程的变量，反之亦然。示例中只是演示了 `fork` 函数的基本用法，实际使用时还需要根据具体需求来处理父子进程之间的通信与同步。

---

# 2. exec函数族

**1. 功能说明：**

`exec()` 系列函数用于在当前进程的上下文中执行一个新的程序，从而替换当前进程的映像。`exec()` 系列函数通常用于在一个进程中启动另一个程序，例如在一个 C/C++ 程序中执行其他的可执行文件，比如 shell 脚本、系统命令、其他可执行程序等。

**2. 函数原型：**

```c
#include <unistd.h>

int execl(const char *path, const char *arg0, ... /* (char *)NULL */);
int execv(const char *path, char *const argv[]);
int execle(const char *path, const char *arg0, ... /* (char *)NULL, char *const envp[] */);
int execve(const char *path, char *const argv[], char *const envp[]);
int execlp(const char *file, const char *arg0, ... /* (char *)NULL */);
int execvp(const char *file, char *const argv[]);
```

**3. 参数说明：**

- `path`：要执行的程序文件的路径名或文件名。如果 `path` 中包含斜杠（`/`），则视为文件路径名，否则将在 `PATH` 环境变量指定的目录中查找可执行文件。
- `arg0`：执行的程序的名称，通常作为参数传递给被调用的程序。`arg0` 是执行程序的第一个参数，它通常是被调用程序的名称。在 `exec()` 系列函数中，`arg0` 参数需要显式地指定，且它必须是被调用程序的名称。后续参数可以是可变长参数列表或者是指向参数数组的指针。
- `argv`：一个指向参数数组的指针，用于传递给被调用程序的命令行参数列表。参数数组以 NULL 结尾，即最后一个元素为 NULL。
- `envp`：一个指向环境变量数组的指针，用于传递给被调用程序的环境变量列表。环境变量数组以 NULL 结尾，即最后一个元素为 NULL。`envp` 参数通常在 `execle()` 和 `execve()` 函数中使用，其他函数中不需要。

**4. 返回值：**

- 如果 `exec()` 系列函数调用成功，它们不会返回到调用进程。只有在发生错误时，这些函数才会返回 -1，并设置全局变量 `errno` 表示具体的错误信息。
- 函数调用成功时不会返回到调用进程
- 函数调用失败时返回`-1`

**5. 使用示例：**

```c
#include <unistd.h>
#include <stdio.h>

int main() {
    // 使用 execl() 执行 ls 命令
    // execl 函数的最后一个参数必须是 NULL
    execl("/bin/ls", "ls", "-l", NULL);

    // 如果 execl 执行成功，则不会执行下面的代码
    // 如果执行失败，则输出错误信息
    perror("execl");
    return 1;
}
```

在上述示例中，我们使用 `execl()` 函数执行 `ls` 命令。`execl()` 函数以 `"/bin/ls"` 作为要执行的程序的路径名，`"ls"` 作为要执行的程序的名称，并传递 `-l` 参数作为命令行参数。`execl()` 函数只有在执行失败时才会返回，如果执行成功，它不会返回到调用进程，而是直接将当前进程替换为 `ls` 命令的执行结果。

需要注意的是，`exec()` 系列函数在执行成功后会替换当前进程的映像，因此后续代码不会继续执行。因此，如果希望在执行成功后继续执行后续代码，应该在 `execl()` 函数之后添加相应的逻辑。另外，由于 `exec()` 系列函数在执行成功后不会返回，所以一般情况下不需要检查它们的返回值。示例中只是演示了

# **3. exit()**

**1. 功能说明：**

`exit()` 函数用于终止当前进程的执行，并返回一个状态码给父进程。调用 `exit()` 函数会导致当前进程的所有打开文件被关闭，所有未刷新的缓冲区被刷新，并且内存中的数据被写回到磁盘。然后，操作系统会回收当前进程的所有资源，并将状态码返回给父进程。

**2. 函数原型：**

```c
#include <stdlib.h>

void exit(int status);
```

**3. 参数说明：**

- `status`：一个整数值，表示进程的终止状态。通常情况下，0 表示成功终止，非零值表示错误的终止状态。

**4. 返回值：**

- `exit()` 函数没有返回值，它会直接终止当前进程的执行。

**5. 使用示例：**

```c
#include <stdlib.h>
#include <stdio.h>

int main() {
    printf("正在执行主程序...\n");

    // 执行一些操作...

    // 调用 exit() 终止进程，并返回状态码 0
    exit(0);

    // 由于 exit() 终止了进程，后续代码不会执行
    printf("这行代码不会执行\n");
    
    return 0;
}
```

在上述示例中，我们调用 `exit(0)` 终止了当前进程的执行，并返回状态码 0 给父进程。在调用 `exit()` 函数后，后续的代码不会执行，因为进程已经被终止。需要注意的是，如果后续代码需要执行一些必要的操作（例如释放资源、保存数据等），应该在调用 `exit()` 函数之前完成，因为 `exit()` 函数会终止当前进程，后续代码不会被执行。

在示例中，简单地使用 `exit()` 终止了进程，并返回状态码 0，父进程可以通过 `wait()` 或 `waitpid()` 函数来检查子进程的返回状态码，以判断子进程是正常终止还是出现了错误。

# **4. _exit()**

**_exit()**

**1. 功能说明：**

`_exit()` 函数用于终止当前进程的执行，与 `exit()` 函数类似，但是 `_exit()` 函数不会执行任何清理操作，包括不会刷新文件缓冲区、不会关闭文件描述符、不会调用 `atexit()` 注册的退出函数等。它是一个系统调用，直接终止进程的执行，不进行任何资源回收。

**2. 函数原型：**

```c
#include <unistd.h>

void _exit(int status);
```

**3. 参数说明：**

- `status`：一个整数值，表示进程的终止状态。通常情况下，0 表示成功终止，非零值表示错误的终止状态。

**4. 返回值：**

- `_exit()` 函数没有返回值，它会直接终止当前进程的执行。

**5. 使用示例：**

```c
#include <unistd.h>
#include <stdio.h>

int main() {
    printf("正在执行主程序...\n");

    // 执行一些操作...

    // 调用 _exit() 终止进程，并返回状态码 0
    _exit(0);

    // 由于 _exit() 终止了进程，后续代码不会执行
    printf("这行代码不会执行\n");
    
    return 0;
}
```

在上述示例中，我们调用 `_exit(0)` 终止了当前进程的执行，并返回状态码 0 给父进程。与 `exit()` 函数不同，`_exit()` 函数直接终止进程的执行，不会进行任何清理操作。因此，调用 `_exit()` 函数后，后续的代码不会执行，文件缓冲区不会被刷新，文件描述符不会被关闭，也不会执行 `atexit()` 注册的退出函数。如果需要执行这些清理操作，应该使用 `exit()` 函数。

在使用 `_exit()` 函数时需要注意，它直接终止进程，会导致所有未刷新的缓冲区内容丢失，并可能导致文件系统的数据不完整。因此，通常情况下应该优先考虑使用 `exit()` 函数，除非特别需要避免执行清理操作时，才考虑使用 `_exit()` 函数。

# **5. wait()**


**1. 功能说明：**

`wait()` 函数用于父进程等待并接收子进程的终止状态。当一个子进程终止时，内核会将子进程的终止状态保存在一个变量中，并让父进程通过调用 `wait()` 函数来获取这个终止状态。如果子进程尚未终止，父进程调用 `wait()` 函数将会阻塞，直到有一个子进程终止。

**2. 函数原型：**

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *status);
```

**3. 参数说明：**

- `status`：一个指向整型变量的指针，用于接收子进程的终止状态。`status` 变量保存了子进程的退出状态，可以通过一些宏来获取子进程的退出状态，例如 `WIFEXITED(status)` 和 `WEXITSTATUS(status)`。

**4. 返回值：**

- 如果调用成功并且有一个子进程终止，`wait()` 函数返回子进程的进程 ID（PID）。
- 如果调用失败或者没有子进程终止，则返回 -1，并设置全局变量 `errno` 表示具体的错误信息。

**5. 使用示例：**

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == -1) {
        perror("fork");
        return 1;
    } else if (pid == 0) {
        // 子进程
        printf("子进程：%d\n", getpid());
        sleep(2); // 子进程休眠 2 秒
        printf("子进程：%d 结束\n", getpid());
        return 42; // 子进程返回状态码 42
    } else {
        // 父进程
        printf("父进程：%d\n", getpid());
        int status;
        pid_t result = wait(&status); // 等待子进程终止并获取其状态

        if (result == -1) {
            perror("wait");
            return 1;
        }

        if (WIFEXITED(status)) {
            // 子进程正常终止
            int exit_status = WEXITSTATUS(status);
            printf("父进程：子进程 %d 正常终止，状态码为 %d\n", result, exit_status);
        } else {
            printf("父进程：子进程 %d 异常终止\n", result);
        }
    }

    return 0;
}
```

在上述示例中，我们创建了一个子进程，子进程打印出自己的 PID，然后休眠 2 秒后终止，并返回状态码 42。父进程调用 `wait()` 函数等待子进程终止，并获取子进程的退出状态。最后，父进程根据子进程的退出状态输出相应的信息。需要注意的是，父进程调用 `wait()` 函数后会阻塞，直到子进程终止。因此，输出结果可能类似于：

```
子进程：12345
父进程：12344
子进程：12345 结束
父进程：子进程 12345 正常终止，状态码为 42
```

在示例中，父进程在子进程终止后获取到了子进程的终止状态，并正确判断子进程是正常终止并返回状态码 42。

# **6. waitpid()**


**1. 功能说明：**

回收指定的子进程，可以设置是否阻塞

**2. 函数原型：**

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options);
```

**3. 参数说明：**

- `pid`:
  - `pid > 0` : 回收进程号为`pid`的子进程
  - `pid = 0` : 回收当前进程组中的任意一个子进程
  - `pid = -1` : 回收任意一个子进程
  - `pid < -1` : 回收`pgid = |pid|`的任何子进程
- `status`：一个指向整型变量的指针，用于接收子进程的终止状态。`status` 变量保存了子进程的退出状态，可以通过一些宏来获取子进程的退出状态，例如 `WIFEXITED(status)` 和 `WEXITSTATUS(status)`。如果不关心子进程的终止状态，可以传入 `NULL`。
- `options`：一个整数值，用于指定额外的选项。常用的选项有：
  - `WNOHANG`：设置非阻塞
  - `0`:阻塞


**4. 返回值：**

- 如果调用成功并且有指定的子进程终止，`waitpid()` 函数返回子进程的进程 ID（PID）。
- 如果指定的子进程尚未终止并且设置了 `WNOHANG` 选项，则返回值为 0。
- 如果调用失败或者没有符合条件的子进程终止，则返回值为 -1，并设置全局变量 `errno` 表示具体的错误信息。

**5. 使用示例：**

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == -1) {
        perror("fork");
        return 1;
    } else if (pid == 0) {
        // 子进程
        printf("子进程：%d\n", getpid());
        sleep(2); // 子进程休眠 2 秒
        printf("子进程：%d 结束\n", getpid());
        return 42; // 子进程返回状态码 42
    } else {
        // 父进程
        printf("父进程：%d\n", getpid());
        int status;

        // 等待指定的子进程终止并获取其状态
        pid_t result = waitpid(pid, &status, 0);

        if (result == -1) {
            perror("waitpid");
            return 1;
        }

        if (WIFEXITED(status)) {
            // 子进程正常终止
            int exit_status = WEXITSTATUS(status);
            printf("父进程：子进程 %d 正常终止，状态码为 %d\n", result, exit_status);
        } else {
            printf("父进程：子进程 %d 异常终止\n", result);
        }
    }

    return 0;
}
```
```C++
    1. waitpid(pid, NULL, WNOHANG); 
        检查当前有没有属于pid的僵尸进程，有则回收，并返回回收的子进程的pid；
        如果当前有属于pid的进程，但是其中没有僵尸进程，则返回0;
        如果没有属于pid的进程，则返回-1
    2. waitpid(pid, NULL, 0);
        成功 : 返回 pid
        失败 : 返回 -1
```







---




# <center> Q&A

## Q1:父子进程之间有哪些资源是共享的，共享行为是怎样的？

- 父进程通过`fork()`创建子进程，子进程会拷贝父进程的虚拟地址空间(一个结构体)，包括页表等等，也就是说父进程通过`fork()`给子进程分配了虚拟地址空间，并且由于子进程也会拷贝父进程的页表，所有父子进程的虚拟地址空间对应的物理内存映射是一样的，只不过并没有为子进程分配物理内存，而是共享父进程的物理内存资源。
- 共享行为———读时共享、写时拷贝: 父进程创建出子进程时，会将可读写的页面标记为只读状态，父子进程均可直接读取数据。当父子进程向这种页面写数据时，会发生`缺页异常`引发中断，缺页中断处理函数将要写的内存页复制一份，并将写数据进程的页表进行更新。当共享的内存页`引用计数`为1时，会将内存页的只读标记更新为可读可写。
- 内核通过读时共享，写时拷贝策略提高了进程创建的效率，以及内存空间的合理利用

但是父子进程总要写数据，如果对应的物理内存资源一直处于共享状态岂不是通过一个进程修改的数据，另一个进程相应的数据也会发生变化？因此

## Q2:进程退出后会发生什么？

- 父进程先于子进程退出时，子进程会变成孤儿进程，孤儿进程将由`init`进程接管
- 子进程退出时父进程没有回收子进程的资源，这时子进程变成僵尸进程，只能等父进程退出后才能被系统回收
## Q3:exit()和_exit()有什么区别？

- `exit()`和`_exit()`函数都是进程退出函数，区别在于`exit()`函数会在先做一些清理工作再退出进程，比如关闭文件描述符，刷新缓存区，脏数据写回等操作，而`_exit()`不会做清理操作，会直接退出。实际上`exit()`内部调用了`_exit()`，不过在调用`_exit()`前，会先调用`atexit()`注册的退出处理函数，用来执行一些清理工作。